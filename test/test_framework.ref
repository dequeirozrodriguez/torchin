* test_framework.ref - Simple test framework for RefTorch
*
* Provides:
* - Assert functions for testing
* - Test runner with pass/fail counting
* - Colored output for results

$EXTERN TSetSeed, TFreeAll, TCount, TEqual, TAllClose;
$EXTERN TPrint, TItem, TShape, TDim, TNumel;


*==============================================================================
* TEST RESULT TRACKING
*==============================================================================

* Global counters stored in static computation
* We use a workaround: pass counts through the computation

* <RunTests e.TestFunctions> == (s.Passed s.Failed)
$ENTRY RunTests {
  e.Tests = <Prout>
            <Prout '========================================'>
            <Prout '       RefTorch Test Suite'>
            <Prout '========================================'>
            <Prout>
            <TSetSeed 42>
            <DoRunTests 0 0 e.Tests>;
}

DoRunTests {
  s.Pass s.Fail = <Prout>
                  <Prout '========================================'>
                  <Prout '             RESULTS'>
                  <Prout '========================================'>
                  <Prout 'Passed: ' s.Pass>
                  <Prout 'Failed: ' s.Fail>
                  <Prout 'Total:  ' <Add s.Pass s.Fail>>
                  <Prout '========================================'>
                  <TFreeAll>
                  (s.Pass s.Fail);
  
  /* Removed broken clause for (e.Name) */

  s.Pass s.Fail t.Fn e.Rest
    = <Prout '--- ' <FnName t.Fn> ' ---'>
      <Mu t.Fn> : (s.P s.F)
    = <DoRunTests <Add s.Pass s.P> <Add s.Fail s.F> e.Rest>;
}

FnName { s.Fn = s.Fn; }


*==============================================================================
* ASSERTION HELPERS
*==============================================================================

* <AssertTrue s.Name s.Condition> == (s.Pass s.Fail)
$ENTRY AssertTrue {
  e.Name 1 = <Prout '  [PASS] ' e.Name> (1 0);
  e.Name 0 = <Prout '  [FAIL] ' e.Name ' (expected true)'> (0 1);
  e.Name s.V = <Prout '  [FAIL] ' e.Name ' (got ' s.V ', expected 1)'> (0 1);
}

* <AssertFalse s.Name s.Condition> == (s.Pass s.Fail)
$ENTRY AssertFalse {
  e.Name 0 = <Prout '  [PASS] ' e.Name> (1 0);
  e.Name s.V = <Prout '  [FAIL] ' e.Name ' (got ' s.V ', expected 0)'> (0 1);
}

* <AssertEq e.Name s.Actual s.Expected> == (s.Pass s.Fail)
$ENTRY AssertEq {
  e.Name s.V s.V = <Prout '  [PASS] ' e.Name> (1 0);
  e.Name s.A s.E = <Prout '  [FAIL] ' e.Name ' (got ' s.A ', expected ' s.E ')'> (0 1);
}

* <AssertNear e.Name s.Actual s.Expected s.Tolerance> == (s.Pass s.Fail)
* All values are x1000 fixed point
* <AssertNear e.Name s.Actual s.Expected s.Tolerance>
$ENTRY AssertNear {
  e.Name s.A s.E s.Tol
    = <Sub s.A s.E> : s.RawDiff
    = <CheckZero s.RawDiff> : {
        True = <Prout '  [PASS] ' e.Name> (1 0);
        False
          = <HelperAbs s.RawDiff> : s.Diff
          = <HelperCompare s.Diff s.Tol> : {
              '+' = <Prout '  [FAIL] ' e.Name ' (got ' s.A ', expected ' s.E ', diff=' s.Diff ')'> (0 1);
              s.Other = <Prout '  [PASS] ' e.Name> (1 0);
            };
      };
}

CheckZero {
  0 = True;
  s.X = False;
}

* <AssertTensorEq e.Name s.TensorA s.TensorB> == (s.Pass s.Fail)
$ENTRY AssertTensorEq {
  e.Name s.A s.B
    , <TEqual s.A s.B> : {
        1 = <Prout '  [PASS] ' e.Name> (1 0);
        0 = <Prout '  [FAIL] ' e.Name ' (tensors not equal)'> (0 1);
      };
}

* <AssertTensorClose e.Name s.TensorA s.TensorB> == (s.Pass s.Fail)
$ENTRY AssertTensorClose {
  e.Name s.A s.B
    , <TAllClose s.A s.B 10 1> : {  /* rtol=1e-5, atol=1e-6 */
        1 = <Prout '  [PASS] ' e.Name> (1 0);
        0 = <Prout '  [FAIL] ' e.Name ' (tensors not close)'> (0 1);
      };
}

* <AssertShape e.Name s.Tensor e.ExpectedShape> == (s.Pass s.Fail)
$ENTRY AssertShape {
  (e.Name) s.T e.Shape
    , <TShape s.T> : {
        e.Shape = <Prout '  [PASS] ' e.Name> (1 0);
        e.Actual = <Prout '  [FAIL] ' e.Name ' (got (' e.Actual '), expected (' e.Shape '))'> (0 1);
      };
}

* <AssertDim e.Name s.Tensor s.ExpectedDim> == (s.Pass s.Fail)
$ENTRY AssertDim {
  e.Name s.T s.Dim
    , <TDim s.T> : {
        s.Dim = <Prout '  [PASS] ' e.Name> (1 0);
        s.Actual = <Prout '  [FAIL] ' e.Name ' (got ' s.Actual ', expected ' s.Dim ')'> (0 1);
      };
}

* <AssertNumel e.Name s.Tensor s.ExpectedNumel> == (s.Pass s.Fail)
$ENTRY AssertNumel {
  e.Name s.T s.N
    , <TNumel s.T> : {
        s.N = <Prout '  [PASS] ' e.Name> (1 0);
        s.Actual = <Prout '  [FAIL] ' e.Name ' (got ' s.Actual ', expected ' s.N ')'> (0 1);
      };
}

* <CombineResults (s.P1 s.F1) (s.P2 s.F2) ...> == (s.TotalPass s.TotalFail)
$ENTRY CombineResults {
  = (0 0);
  (s.P s.F) e.Rest = <AddResults (s.P s.F) <CombineResults e.Rest>>;
}

AddResults {
  (s.P1 s.F1) (s.P2 s.F2) = (<Add s.P1 s.P2> <Add s.F1 s.F2>);
}


*==============================================================================
* UTILITY
*==============================================================================

HelperAbs {
  s.N, <HelperCompare s.N 0> : '-' = <Sub 0 s.N>;
  s.N = s.N;
}

HelperCompare {
  s.A s.B, <Sub s.A s.B> : {
    0 = '0';
    s.N, <HelperIsNegative s.N> : True = '-';
    s.N = '+';
  };
}

HelperIsNegative {
  s.N, <Div s.N 1000000000> : {
    0 = <HelperIsNegativeSmall s.N>;
    '-' s.Q = True;
    s.Q = False;
  };
}

HelperIsNegativeSmall {
  0 = False;
  s.N, <Mod s.N 10> : s.N = False;  /* positive single digit */
  s.N = True; /* has more structure - check sign */
}
