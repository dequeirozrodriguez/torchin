* src/models/QwenAttention.ref
* Qwen3 Attention: GQA + RoPE + QK-Norm (No Bias)

$EXTERN TLinearNoBias, TRMSNorm, TRoPE, TUpdateSlice;
$EXTERN TMatMul, TTranspose, TAdd, TDivScalar, TSoftmax, TMul;
$EXTERN TReshape, TRepeat, TShape, TGetDim, TPermute;
$EXTERN TFree, TClone, TSlice, TCat;
$EXTERN ConfigGet; 

* Signature:
* <QwenAttention s.X (s.WQ s.WK s.WV s.WO) (s.QNorm s.KNorm) ...>

$ENTRY QwenAttention {
  s.X (s.WQ s.WK s.WV s.WO) (s.QNorm s.KNorm)
  s.Freqs s.Mask (e.Cfg) s.Pos (s.KC s.VC)
    
    * Get Dims
    = <ConfigGet (e.Cfg) 'num_attention_heads'> : s.Heads
    = <ConfigGet (e.Cfg) 'num_key_value_heads'> : s.KVHeads
    = <ConfigGet (e.Cfg) 'head_dim'> : s.HeadDim
    = <TGetDim s.X 0> : s.Batch
    = <TGetDim s.X 1> : s.SeqLen
    = <ConfigGet (e.Cfg) 'rms_norm_eps'> : s.Eps
    
    * Projections (NO BIAS verified)
    = <TLinearNoBias s.X s.WQ> : s.Q0
    = <TLinearNoBias s.X s.WK> : s.K0
    = <TLinearNoBias s.X s.WV> : s.V0
    
    * Reshape [B, S, H, D]
    = <TReshape s.Q0 s.Batch s.SeqLen s.Heads s.HeadDim> : s.Q_Raw
    = <TReshape s.K0 s.Batch s.SeqLen s.KVHeads s.HeadDim> : s.K_Raw
    = <TReshape s.V0 s.Batch s.SeqLen s.KVHeads s.HeadDim> : s.V
    = <TFree s.Q0> <TFree s.K0> <TFree s.V0>
    
    * QK-NORM
    * Apply RMSNorm to Q and K before RoPE
    = <TRMSNorm s.Q_Raw s.QNorm s.Eps> : s.Q_Normed
    = <TRMSNorm s.K_Raw s.KNorm s.Eps> : s.K_Normed
    = <TFree s.Q_Raw> <TFree s.K_Raw>
    
    * RoPE (Using Normed Q/K)
    = <TSlice s.Freqs 0 s.Pos <Add s.Pos s.SeqLen> 1> : s.FreqsSliced
    = <TRoPE s.Q_Normed s.FreqsSliced> : s.Q_Rot
    = <TRoPE s.K_Normed s.FreqsSliced> : s.K_Rot
    = <TFree s.Q_Normed> <TFree s.K_Normed> <TFree s.FreqsSliced>
    
    * KV Cache Update
    = <TUpdateSlice s.KC s.K_Rot 1 s.Pos> : s.KC_Updated
    = <TUpdateSlice s.VC s.V 1 s.Pos> : s.VC_Updated
    = <TFree s.K_Rot> <TFree s.V>
    
    * Get Full KV & GQA Repeat
    = <Add s.Pos s.SeqLen> : s.TotalLen
    = <TSlice s.KC_Updated 1 0 s.TotalLen 1> : s.K_Full
    = <TSlice s.VC_Updated 1 0 s.TotalLen 1> : s.V_Full
    = <PrepareGQA s.K_Full s.Heads s.KVHeads> : s.K_Ready
    = <PrepareGQA s.V_Full s.Heads s.KVHeads> : s.V_Ready
    
    * Attention Mechanism
    = <TPermute s.Q_Rot 0 2 1 3> : s.Q_T
    = <TPermute s.K_Ready 0 2 3 1> : s.K_T
    = <TMatMul s.Q_T s.K_T> : s.Scores
    = <TDivScalar s.Scores <Sqrt s.HeadDim>> : s.ScaledScores
    
    * Masking & Softmax
    = <ApplyMask s.ScaledScores s.Mask> : s.MaskedScores
    = <TSoftmax s.MaskedScores -1> : s.Probs
    
    * Output: Probs @ V
    = <TPermute s.V_Ready 0 2 1 3> : s.V_T
    = <TMatMul s.Probs s.V_T> : s.Context
    
    * 9. Output Projection (NO BIAS)
    = <TPermute s.Context 0 2 1 3> : s.Context_Contig
    = <TReshape s.Context_Contig s.Batch s.SeqLen <Mul s.Heads s.HeadDim>> : s.Context_Flat
    = <TLinearNoBias s.Context_Flat s.WO> : s.Output
    
    * Cleanup
    = <TFreeAllExcept (s.Output s.KC_Updated s.VC_Updated)>
    
    = s.Output (s.KC_Updated s.VC_Updated);
}

* Helpers
PrepareGQA {
  s.T s.Heads s.KVHeads, <Compare s.Heads s.KVHeads> : '0' = s.T;
  s.T s.Heads s.KVHeads = <TRepeat s.T 2 <Div s.Heads s.KVHeads>>;
}

ApplyMask {
  s.Scores s.Mask
    = <TShape s.Scores> : (s.B s.H s.S s.S_Total)
    = <Compare s.S 1> : {
        '0' = s.Scores; 
        '+' = <TAdd s.Scores s.Mask>;
        '-' = s.Scores;
      };
}

* This stays for now
Sqrt { 64=8; 128=11; 96=9; s.N=10; }
TFreeAllExcept { (e.Keep) = ; }
