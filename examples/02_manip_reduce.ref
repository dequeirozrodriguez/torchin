* 02_manip_reduce.ref - Tensor manipulation and reduction examples
*
* This example demonstrates:
* - Reshaping and transposing tensors
* - Concatenating and stacking
* - Reduction operations (sum, mean, max, etc.)
* - Sorting and statistics

$INCLUDE "RefTorch";

$ENTRY Go {
  = <Main>;
}

Main {
  = <Prout '=== RefTorch Phase 2: Manipulation & Reduction ==='>
    <Prout ''>
    <Example1-Reshape>
    <Example2-Transpose>
    <Example3-Combine>
    <Example4-Slice>
    <Example5-Reduce>
    <Example6-Sort>
    <Cleanup>;
}


*------------------------------------------------------------------------------
* Example 1: Reshaping
*------------------------------------------------------------------------------
Example1-Reshape {
  = <Prout '--- Example 1: Reshaping ---'>
    <Prout ''>
    <DoReshape <TFromList (2 3) (1 2 3 4 5 6)>>;
}

DoReshape {
  s.T = <Prout 'Original (2x3):'>
        <TPrint s.T>
        
        <Prout 'Reshaped to (3x2):'>
        <PrintAndFree <TReshape <TClone s.T> 3 2>>
        
        <Prout 'Flattened (1D):'>
        <PrintAndFree <TFlatten <TClone s.T> 0 1>>
        
        <TFree s.T>
        <Prout ''>;
}


*------------------------------------------------------------------------------
* Example 2: Transposing
*------------------------------------------------------------------------------
Example2-Transpose {
  = <Prout '--- Example 2: Transposing ---'>
    <Prout ''>
    <DoTranspose <TRand 2 3>>;
}

DoTranspose {
  s.T = <Prout 'Original (2x3):'>
        <TPrint s.T>
        
        <Prout 'Transposed (3x2):'>
        <PrintAndFree <TT <TClone s.T>>>
        
        <TFree s.T>
        <Prout ''>;
}


*------------------------------------------------------------------------------
* Example 3: Combine (Cat/Stack)
*------------------------------------------------------------------------------
Example3-Combine {
  = <Prout '--- Example 3: Concatenation & Stacking ---'>
    <Prout ''>
    <DoCombine <TOnes 2 2> <TZeros 2 2>>;
}

DoCombine {
  s.A s.B
    = <Prout 'A (Ones):'> <TPrint s.A>
      <Prout 'B (Zeros):'> <TPrint s.B>
      
      <Prout 'Cat dim 0 (4x2):'>
      <PrintAndFree <TCat (s.A s.B) 0>>
      
      <Prout 'Cat dim 1 (2x4):'>
      <PrintAndFree <TCat (s.A s.B) 1>>
      
      <Prout 'Stack dim 0 (2x2x2):'>
      <PrintAndFree <TStack (s.A s.B) 0>>
      
      <TFree s.A> <TFree s.B>
      <Prout ''>;
}


*------------------------------------------------------------------------------
* Example 4: Slicing
*------------------------------------------------------------------------------
Example4-Slice {
  = <Prout '--- Example 4: Slicing ---'>
    <Prout ''>
    /* 4x4 matrix */
    <DoSlice <TRand 4 4>>;
}

DoSlice {
  s.T = <Prout 'Original (4x4):'>
        <TPrint s.T>
        
        <Prout 'Slice dim 0, indices 1..3 (rows 1,2):'>
        <PrintAndFree <TSlice <TClone s.T> 0 1 3 1>>
        
        <Prout 'Select row 0:'>
        <PrintAndFree <TSelect <TClone s.T> 0 0>>
        
        <TFree s.T>
        <Prout ''>;
}


*------------------------------------------------------------------------------
* Example 5: Reduction
*------------------------------------------------------------------------------
Example5-Reduce {
  = <Prout '--- Example 5: Reduction ---'>
    <Prout ''>
    <DoReduce <TFromList (2 3) (1 2 3 4 5 6)>>;
}

DoReduce {
  s.T = <Prout 'Matrix:'> <TPrint s.T>
        
        <Prout 'Sum (21):'>
        <PrintAndFree <TSum s.T>>
        
        <Prout 'Mean (3.5):'>
        <PrintAndFree <TMean s.T>>
        
        <Prout 'Max (6):'>
        <PrintAndFree <TMax s.T>>
        
        <Prout 'Sum along dim 0 (Columns -> [5, 7, 9]):'>
        <PrintAndFree <TSumDim s.T 0>>
        
        <TFree s.T>
        <Prout ''>;
}


*------------------------------------------------------------------------------
* Example 6: Sorting
*------------------------------------------------------------------------------
Example6-Sort {
  = <Prout '--- Example 6: Sorting ---'>
    <Prout ''>
    /* FIX: Bracketed list for TFromList */
    <DoSort <TFromList (3 4) (12 5 8 1 9 2 11 4 3 10 6 7)>>;
}

DoSort {
  s.T = <Prout 'Original matrix:'>
        <TPrint s.T>
        
        <Prout 'Sort along dim 1 (each row sorted):'>
        /* TSort returns s.Sorted s.Indices */
        <DoSortResult <TSort s.T 1 0>> /* 0=Ascending */
        
        <Prout 'Top 2 values per row:'>
        <DoTopK <TTopK s.T 2 1>>
        
        <TFree s.T>
        <Prout ''>;
}

DoSortResult {
  s.Sorted s.Indices
    = <Prout 'Sorted values:'>
      <TPrint s.Sorted>
      <Prout 'Indices:'>
      <TPrint s.Indices>
      <TFree s.Sorted>
      <TFree s.Indices>;
}

DoTopK {
  s.Values s.Indices
    = <Prout 'Top values:'>
      <TPrint s.Values>
      <Prout 'Top indices:'>
      <TPrint s.Indices>
      <TFree s.Values>
      <TFree s.Indices>;
}


*------------------------------------------------------------------------------
* Helpers
*------------------------------------------------------------------------------
PrintAndFree {
  s.T = <TPrint s.T> <TFree s.T>;
}

Cleanup {
  = <TFreeAll> <Prout 'All tensors freed.'>;
}
