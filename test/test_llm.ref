* test_llm.ref - Tests for LLM-specific operations
* (Fixed: Large literal workaround using runtime calculation)

$EXTERN RunTests, AssertTrue, AssertEq, AssertNear, AssertTensorEq, AssertTensorClose, CombineResults;
$EXTERN TFromList, TFree, TFreeAll, TClone, TItem, TSlice, TShape;
$EXTERN TZeros, TOnes, TFull;
$EXTERN TAdd, TSub, TMul;

* LLM Ops
$EXTERN TSilu, TSwiGLU, TRMSNorm, TRoPE, TPrecomputeFreqs;
$EXTERN TTopKMask, TTopPMask;

$ENTRY Go {
  = <RunTests
      TestSiLU
      TestSwiGLU
      TestRMSNorm
      TestTopK
      TestTopP
      TestRoPE
    >;
}


*==============================================================================
* ACTIVATION TESTS
*==============================================================================

$ENTRY TestSiLU {
  = <DoTestSiLU>;
}
DoTestSiLU {
  e.In
    , <TFromList (3) (<Sub 0 10> 0 10)> : s.T
    , <TSilu s.T> : s.Out
    
    , <TItem <TSlice s.Out 0 0 1 1>> : e.V0
    , <TItem <TSlice s.Out 0 1 2 1>> : e.V1
    , <TItem <TSlice s.Out 0 2 3 1>> : e.V2
    
    , <DecodeSigned32 e.V0> : e.D0
    , <DecodeSigned32 e.V1> : e.D1
    , <DecodeSigned32 e.V2> : e.D2
    
    , <CombineResults
        <AssertTrue 'silu -10' <CheckInRange (e.D0) (<Sub 0 10>) (10)>>
        <AssertTrue 'silu 0'   <CheckInRange (e.D1) (<Sub 0 10>) (10)>>
        <AssertTrue 'silu 10'  <CheckInRange (e.D2) (9990) (10010)>>
      > : t.Res
    
    = <TFree s.T> <TFree s.Out> t.Res;
}

$ENTRY TestSwiGLU {
  = <DoTestSwiGLU>;
}
DoTestSwiGLU {
  e.In
    , <TFromList (1) (10)> : s.Gate
    , <TFromList (1) (2)> : s.Val
    , <TSwiGLU s.Gate s.Val> : s.Out
    
    , <TItem s.Out> : e.Val
    , <DecodeSigned32 e.Val> : e.DVal
    , <CheckInRange (e.DVal) (19900) (20100)> : s.Ok
    
    , <CombineResults
        <AssertTrue 'swiglu value ok' s.Ok>
      > : t.Res
      
    = <TFree s.Gate> <TFree s.Val> <TFree s.Out> t.Res;
}


*==============================================================================
* NORMALIZATION TESTS
*==============================================================================

$ENTRY TestRMSNorm {
  = <DoTestRMSNorm>;
}
DoTestRMSNorm {
  e.In
    , <TFromList (2) (3 4)> : s.T
    , <TOnes 2> : s.W
    , <TRMSNorm s.T s.W 1> : s.Out
    
    , <TItem <TSlice s.Out 0 0 1 1>> : e.V1
    , <TItem <TSlice s.Out 0 1 2 1>> : e.V2
    
    , <CombineResults
        <AssertTrue 'rmsnorm v1' <CheckInRange (e.V1) (840) (860)>>
        <AssertTrue 'rmsnorm v2' <CheckInRange (e.V2) (1120) (1140)>>
      > : t.Res
      
    = <TFree s.T> <TFree s.W> <TFree s.Out> t.Res;
}


*==============================================================================
* SAMPLING TESTS
*==============================================================================

$ENTRY TestTopK {
  = <DoTestTopK>;
}
DoTestTopK {
  e.In
    , <TFromList (5) (10 1 8 2 5)> : s.Logits
    , <TTopKMask s.Logits 2 1000> : s.Masked
    
    , <TItem <TSlice s.Masked 0 0 1 1>> : e.V0 /* 10000 */
    , <TItem <TSlice s.Masked 0 2 3 1>> : e.V2 /* 8000 */
    , <TItem <TSlice s.Masked 0 1 2 1>> : e.V1 /* Masked (-1000000) */
    
    , <DecodeSigned32 e.V1> : e.DecodedV1
    
    , <CombineResults
        <AssertEq 'topk preserved 1' e.V0 10000>
        <AssertEq 'topk preserved 2' e.V2 8000>
        <AssertTrue 'topk masked' <CheckEq (e.DecodedV1) (<Sub 0 1000000>)>>
      > : t.Res
      
    = <TFree s.Logits> <TFree s.Masked> t.Res;
}

$ENTRY TestTopP {
  = <DoTestTopP>;
}
DoTestTopP {
  e.In
    , <TFromList (4) (10 0 0 0)> : s.Logits
    , <TTopPMask s.Logits 500 1000> : s.Masked
    
    , <TItem <TSlice s.Masked 0 0 1 1>> : e.V0
    , <TItem <TSlice s.Masked 0 1 2 1>> : e.V1
    
    , <DecodeSigned32 e.V1> : e.DecodedV1
    
    , <CombineResults
        <AssertEq 'topp keep' e.V0 10000>
        <AssertTrue 'topp mask' <CheckEq (e.DecodedV1) (<Sub 0 1000000>)>>
      > : t.Res
      
    = <TFree s.Logits> <TFree s.Masked> t.Res;
}


*==============================================================================
* POSITIONAL TESTS
*==============================================================================

$ENTRY TestRoPE {
  = <DoTestRoPE>;
}
DoTestRoPE {
  e.In
    , <TPrecomputeFreqs 4 10 10000> : s.Freqs
    , <TOnes 1 2 1 4> : s.Q
    , <TSlice s.Freqs 0 0 2 1> : s.FreqsSliced
    , <TRoPE s.Q s.FreqsSliced> : s.Rotated
    
    , <TShape s.Q> : e.ShapeQ
    , <TShape s.Rotated> : e.ShapeRot
    
    , <CombineResults
        <AssertTrue 'rope shape' <CheckShapes (e.ShapeQ) (e.ShapeRot)>>
      > : t.Res
      
    = <TFree s.Freqs> <TFree s.Q> <TFree s.Rotated> t.Res;
}


*==============================================================================
* ROBUST LOGIC
*==============================================================================

/* Helper to generate 2^32 without literal overflow */
GetWrapAroundConst {
  = <Mul 65536 65536>;
}

DecodeSigned32 {
  /* 2147483647 is max signed 32-bit int */
  s.N, <Compare s.N 2147483647> : {
    '+' = <Sub s.N <GetWrapAroundConst>>;
    s.Other = s.N;
  };
  '-' s.N = '-' s.N; 
  (e.Expr) = <DecodeSigned32 e.Expr>;
}

CheckShapes {
  (e.S) (e.S) = 1;
  (e.A) (e.B) = 0;
}

CheckEq {
  (e.A) (e.B), <CompareExpr (e.A) (e.B)> : {
      '0' = 1;
      s.Other = 0;
  };
}

CompareExpr {
  (e.A) (e.B) = <CompNormalized <Normalize e.A> <Normalize e.B>>;
}

Normalize {
  '-' s.N = ('-') s.N;
  s.N     = <CheckSign s.N>;
}

CheckSign {
  s.N, <Compare s.N 0> : {
      '-' = ('-') <Sub 0 s.N>;
      s.Other = ('+') s.N;
  };
}

CompNormalized {
  ('-') s.A ('+') s.B = '-';
  ('+') s.A ('-') s.B = '+';
  ('+') s.A ('+') s.B = <Compare s.A s.B>;
  ('-') s.A ('-') s.B, <Compare s.A s.B> : { '+' = '-'; '-' = '+'; '0' = '0'; };
}

CheckInRange {
  (e.Val) (e.Min) (e.Max), <CompareExpr (e.Val) (e.Min)> : {
      '-' = 0; 
      s.Other = <CompareExpr (e.Val) (e.Max)> : {
          '+' = 0; 
          s.OK = 1;
      };
  };
}
