* src/models/QwenAttention.ref
* Qwen3 Attention: GQA + RoPE + QK-Norm (NO BIAS)

$INCLUDE "RefTorch";

$EXTERN TRMSNorm, TRoPE, TUpdateSlice;
$EXTERN TMatMul, TTranspose, TAdd, TDivScalar, TSoftmax, TMul, TSub;
$EXTERN TReshape, TRepeat, TRepeatInterleave, TShape, TGetDim, TPermute;
$EXTERN TFree, TClone, TSlice, TCat;
$EXTERN ConfigGet; 

$ENTRY QwenAttention {
  /* INPUT: Weights only (No Biases) */
  s.X (s.WQ s.WK s.WV s.WO) (s.QNorm s.KNorm)
  s.Freqs s.Mask (e.Cfg) s.Pos (s.KC s.VC)
    
    /* 1. Get Dims */
    = <ConfigGet (e.Cfg) 'num_attention_heads'> : s.Heads
    , <ConfigGet (e.Cfg) 'num_key_value_heads'> : s.KVHeads
    , <ConfigGet (e.Cfg) 'head_dim'> : s.HeadDim
    , <TGetDim s.X 0> : s.Batch
    , <TGetDim s.X 1> : s.SeqLen
    , <ConfigGet (e.Cfg) 'rms_norm_eps'> : s.Eps
    
    /* 2. Projections (NO BIAS) */
    , <TLinearNoBias s.X s.WQ> : s.Q0
    /* , <Prout 'Q0[0,0,:5]: '> <TPrint <TSlice <TSlice <TSlice s.Q0 0 0 1 1> 1 0 1 1> 2 0 5 1>> : e.DbgQ0 */
    , <TLinearNoBias s.X s.WK> : s.K0
    , <TLinearNoBias s.X s.WV> : s.V0
    
    /* 3. Reshape */
    , <TReshape s.Q0 s.Batch s.SeqLen s.Heads s.HeadDim> : s.Q_Raw
    , <TReshape s.K0 s.Batch s.SeqLen s.KVHeads s.HeadDim> : s.K_Raw
    , <TReshape s.V0 s.Batch s.SeqLen s.KVHeads s.HeadDim> : s.V
    , <TFree s.Q0> <TFree s.K0> <TFree s.V0> : e.F1
    
    /* 4. QK-NORM */
    , <TRMSNorm s.Q_Raw s.QNorm s.Eps> : s.Q_Normed
    /*, <Prout 'Q_Normed[0,0,0,:5]: '> <TPrint <TSlice <TSlice <TSlice <TSlice s.Q_Normed 0 0 1 1> 1 0 1 1> 2 0 1 1> 3 0 5 1>> : e.DbgQN */
    , <TRMSNorm s.K_Raw s.KNorm s.Eps> : s.K_Normed
    , <TFree s.Q_Raw> <TFree s.K_Raw> : e.F2
    
    /* 5. RoPE */
    , <TSlice s.Freqs 0 s.Pos <Add s.Pos s.SeqLen> 1> : s.FreqsSliced
    , <TRoPE s.Q_Normed s.FreqsSliced> : s.Q_Rot
    /*, <Prout 'Q_Rot[0,0,0,:5]: '> <TPrint <TSlice <TSlice <TSlice <TSlice s.Q_Rot 0 0 1 1> 1 0 1 1> 2 0 1 1> 3 0 5 1>> : e.DbgQR */
    , <TRoPE s.K_Normed s.FreqsSliced> : s.K_Rot
    , <TFree s.Q_Normed> <TFree s.K_Normed> <TFree s.FreqsSliced> : e.F3
    
    /* 6. KV Cache (FIX: Clone Update to break aliasing) */
    , <TClone s.K_Rot> : s.K_Rot_Safe
    , <TClone s.V> : s.V_Safe
    , <ManualUpdateKVCache s.KC s.VC s.K_Rot_Safe s.V_Safe s.Pos> : (s.KC_Updated s.VC_Updated)
    , <TFree s.K_Rot> <TFree s.K_Rot_Safe> <TFree s.V> <TFree s.V_Safe> : e.F4
    
    /* 7. Get Full KV */
    , <Add s.Pos s.SeqLen> : s.TotalLen
    , <TSlice s.KC_Updated 1 0 s.TotalLen 1> : s.K_Full
    , <TSlice s.VC_Updated 1 0 s.TotalLen 1> : s.V_Full
    , <PrepareGQA s.K_Full s.Heads s.KVHeads> : s.K_Ready
    , <PrepareGQA s.V_Full s.Heads s.KVHeads> : s.V_Ready
    
    /* 8. Attention */
    , <TPermute s.Q_Rot 0 2 1 3> : s.Q_T
    , <TPermute s.K_Ready 0 2 3 1> : s.K_T

    /* DEBUG: Print shapes and values before matmul */
    , <Prout 'Q_T shape: ' <TShape s.Q_T>> : e.DbgQTs
    , <Prout 'K_T shape: ' <TShape s.K_T>> : e.DbgKTs
    , <Prout 'K_Ready[0,0,0,:5]: '> <TPrint <TSlice <TSlice <TSlice <TSlice s.K_Ready 0 0 1 1> 1 0 1 1> 2 0 1 1> 3 0 5 1>> : e.DbgKR


    , <TMatMul s.Q_T s.K_T> : s.Scores
    /*, <TDivScalar s.Scores <Sqrt s.HeadDim>> : s.ScaledScores*/
    , <TDivScalar s.Scores <Mul 1000 <Sqrt s.HeadDim>>> : s.ScaledScores
    /*, <Prout 'Scaled scores[0,0,0,:]: '> <TPrint <TSlice <TSlice <TSlice <TSlice s.ScaledScores 0 0 1 1> 1 0 1 1> 2 0 1 1> 3 0 6 1>> : e.DbgSc2 */
    , <ApplyMask s.ScaledScores s.Mask s.Pos> : s.MaskedScores
    /*, <Prout 'Masked scores[0,0,0,:]: '> <TPrint <TSlice <TSlice <TSlice <TSlice s.MaskedScores 0 0 1 1> 1 0 1 1> 2 0 1 1> 3 0 6 1>> : e.DbgMasked*/
    /*, <Prout 'Mask shape: ' <TShape s.Mask>> : e.DbgMaskShape */
    /*, <Prout 'Mask[0,0,:3,:3]: '> <TPrint <TSlice <TSlice <TSlice <TSlice s.Mask 0 0 1 1> 1 0 1 1> 2 0 3 1> 3 0 3 1>> : e.DbgMaskVals */
    , <TSoftmax s.MaskedScores 3> : s.Probs
    /*, <Prout 'Probs[0,0,0,:6]: '> <TPrint <TSlice <TSlice <TSlice <TSlice s.Probs 0 0 1 1> 1 0 1 1> 2 0 1 1> 3 0 6 1>> : e.DbgProbs*/    
    /*, <Prout 'V_Ready[0,0,0,:5]: '> <TPrint <TSlice <TSlice <TSlice <TSlice s.V_Ready 0 0 1 1> 1 0 1 1> 2 0 1 1> 3 0 5 1>> : e.DbgV*/

    /* Output */
    , <TPermute s.V_Ready 0 2 1 3> : s.V_T
    , <TMatMul s.Probs s.V_T> : s.Context
    /*, <Prout 'Context[0,0,0,:5]: '> <TPrint <TSlice <TSlice <TSlice <TSlice s.Context 0 0 1 1> 1 0 1 1> 2 0 1 1> 3 0 5 1>> : e.DbgCtx*/


    /* 9. Projection (NO BIAS) */
    , <TPermute s.Context 0 2 1 3> : s.Context_Contig
    /*, <Prout 'Context_Contig shape: ' <TShape s.Context_Contig>> : e.DbgCCs*/
    , <TReshape s.Context_Contig s.Batch s.SeqLen <Mul s.Heads s.HeadDim>> : s.Context_Flat
    /*, <Prout 'Context_Flat shape: ' <TShape s.Context_Flat>> : e.DbgCFs*/
    /*, <Prout 'Context_Flat[0,0,:5]: '> <TPrint <TSlice <TSlice <TSlice s.Context_Flat 0 0 1 1> 1 0 1 1> 2 0 5 1>> : e.DbgCFV*/
    /*, <Prout 'WO shape: ' <TShape s.WO>> : e.DbgWOs*/
    /*, <Prout 'WO[0,:5]: '> <TPrint <TSlice <TSlice s.WO 0 0 1 1> 1 0 5 1>> : e.DbgWOvals
    
    , <Prout 'Context_Flat[0,0,:5]: '> <TPrint <TSlice <TSlice <TSlice s.Context_Flat 0 0 1 1> 1 0 1 1> 2 0 5 1>> : e.DbgCF1
    , <Prout 'Context_Flat[0,0,128:133] (head1 start): '> <TPrint <TSlice <TSlice <TSlice s.Context_Flat 0 0 1 1> 1 0 1 1> 2 128 133 1>> : e.DbgCF2
    , <Prout 'Context_Flat[0,0,256:261] (head2 start): '> <TPrint <TSlice <TSlice <TSlice s.Context_Flat 0 0 1 1> 1 0 1 1> 2 256 261 1>> : e.DbgCF3

    , <TLinearNoBias s.Context_Flat s.WO> : s.Output
    , <Prout 'Attn Output[0,0,:5]: '> <TPrint <TSlice <TSlice <TSlice s.Output 0 0 1 1> 1 0 1 1> 2 0 5 1>> : e.DbgOutFinal*/
    , <Prout 'Context_Flat[0,0,:5]: '> <TPrint <TSlice <TSlice <TSlice s.Context_Flat 0 0 1 1> 1 0 1 1> 2 0 5 1>> : e.DbgCF1
    , <Prout 'Context_Flat[0,0,128:133] (head1 start): '> <TPrint <TSlice <TSlice <TSlice s.Context_Flat 0 0 1 1> 1 0 1 1> 2 128 133 1>> : e.DbgCF2
    , <Prout 'Context_Flat[0,0,256:261] (head2 start): '> <TPrint <TSlice <TSlice <TSlice s.Context_Flat 0 0 1 1> 1 0 1 1> 2 256 261 1>> : e.DbgCF3
    , <TTranspose s.WO 0 1> : s.WO_T
    , <Prout 'WO_T shape: ' <TShape s.WO_T>> : e.DbgWOTs
    , <Prout 'WO_T[0,:5]: '> <TPrint <TSlice <TSlice s.WO_T 0 0 1 1> 1 0 5 1>> : e.DbgWOTv
    , <TMatMul s.Context_Flat s.WO_T> : s.Output
    , <Prout 'Output shape: ' <TShape s.Output>> : e.DbgOuts
    , <Prout 'Attn Output[0,0,:5]: '> <TPrint <TSlice <TSlice <TSlice s.Output 0 0 1 1> 1 0 1 1> 2 0 5 1>> : e.DbgOutFinal
    , <TFree s.WO_T> : e.Ignore2
    , <TFreeAllExcept (s.Output s.KC_Updated s.VC_Updated)> : e.F5
    
    = s.Output (s.KC_Updated s.VC_Updated);
}

/* ========================================================================= */
/* HELPERS */
/* ========================================================================= */

ManualUpdateKVCache {
  s.KC s.VC s.K_Up s.V_Up s.Pos
    = <ManualUpdateStep2 s.VC s.V_Up s.Pos <DoManualSlice s.KC s.K_Up 1 s.Pos>>;
}

ManualUpdateStep2 {
  s.VC s.V_Up s.Pos s.KC_New
    = (s.KC_New <DoManualSlice s.VC s.V_Up 1 s.Pos>);
}

DoManualSlice {
  s.Cache s.Update s.Dim s.Pos
    = <DoManualSlice_Shape s.Cache s.Update s.Dim s.Pos <TShape s.Update>>;
}

DoManualSlice_Shape {
  s.Cache s.Update s.Dim s.Pos (s.B s.ULen s.H s.D) 
    = <DoManualSlice_Logic s.Cache s.Update s.Dim s.Pos s.ULen>;
  s.Cache s.Update s.Dim s.Pos s.B s.ULen s.H s.D
    = <DoManualSlice_Logic s.Cache s.Update s.Dim s.Pos s.ULen>;
}

DoManualSlice_Logic {
  s.Cache s.Update s.Dim s.Pos s.ULen
    = <DoManualSlice_Exec s.Cache s.Update s.Dim s.Pos <Add s.Pos s.ULen>>;
}

DoManualSlice_Exec {
  s.Cache s.Update s.Dim s.Pos s.EndPos
    = <DoManualSlice_Final s.Cache s.Update s.Dim s.Pos s.EndPos <TGetDim s.Cache s.Dim>>;
}

/* FIX: TClone slices before TCat to force memory realization */
DoManualSlice_Final {
  /* Case 1: Start of Cache */
  s.Cache s.Update s.Dim 0 s.EndPos s.Total
    , <TSlice s.Cache s.Dim s.EndPos s.Total 1> : s.Suffix
    , <TClone s.Suffix> : s.SuffixSafe
    = <TCat (s.Update s.SuffixSafe) s.Dim>;

  /* Case 2: Middle/End */
  s.Cache s.Update s.Dim s.Pos s.EndPos s.Total
    /* FIX REVERTED: Slice 0 to Pos (exclusive) is correct. */
    , <TSlice s.Cache s.Dim 0 s.Pos 1> : s.Prefix
    , <TSlice s.Cache s.Dim s.EndPos s.Total 1> : s.Suffix
    , <TClone s.Prefix> : s.PrefixSafe
    , <TClone s.Suffix> : s.SuffixSafe
    = <TCat (s.PrefixSafe s.Update s.SuffixSafe) s.Dim>;
}

/* Other Helpers */
/*
PrepareGQA {
  s.T s.Heads s.KVHeads, <Compare s.Heads s.KVHeads> : '0' = s.T;
  s.T s.Heads s.KVHeads = <TRepeat s.T 1 1 <Div s.Heads s.KVHeads> 1>;
}
*/
PrepareGQA {
  s.T s.Heads s.KVHeads, <Compare s.Heads s.KVHeads> : '0' = s.T;
  s.T s.Heads s.KVHeads = <TRepeatInterleave s.T 2 <Div s.Heads s.KVHeads>>;
}

ApplyMask {
  s.Scores s.Mask s.Pos = <DoApplyMask s.Scores s.Mask s.Pos <TShape s.Scores>>;
}
DoApplyMask {
  s.Scores s.Mask s.Pos (s.B s.H s.S s.Total) = <SliceAndAdd s.Scores s.Mask s.Pos s.S>;
  s.Scores s.Mask s.Pos s.B s.H s.S s.Total = <SliceAndAdd s.Scores s.Mask s.Pos s.S>;
}
SliceAndAdd {
  s.Scores s.Mask s.Pos s.SeqLen
    , <Compare s.SeqLen 1> : {
        '0' = s.Scores;
        '+' = <TAdd s.Scores <TSlice <TSlice s.Mask 2 s.Pos <Add s.Pos s.SeqLen> 1> 3 0 <Add s.Pos s.SeqLen> 1>>;
        '-' = s.Scores;
      };
}

TLinearNoBias {
  s.Input s.Weight
    = <TTranspose s.Weight 0 1> : s.WeightT
    , <TMatMul s.Input s.WeightT> : s.Output
    , <TFree s.WeightT> : e.Ignore
    = s.Output;
}

Sqrt { 64=8; 128=11; 96=9; s.N=10; }
TFreeAllExcept { (e.Keep) = ; }
